%{
import 'package:source_span/source_span.dart';
import 'ast.dart';

bool _checkAttr(String attr, int start, int end, State state) {
  if (attr == "const" || attr == "close") return true;
  state.error("Invalid attribute '$attr'", start, end, 0);
  return false;
}

Program parse(String source, {Object? url}) {
  final state = State(source);
  final file = SourceFile.fromString(source, url:url);
  final parser = GrammarParser(file);

  final result = parser.parseStart(state);
  if (result == null) {
    throw FormatException(
      state
          .getErrors()
          .map((e) => file.span(e.start, e.end).message(e.message))
          .join('\n'),
    );
  }

  return result.$1;
}

}%
%%

bool isReserved(String name) {
  const reserved = {
    "function",
    "end",
    "if",
    "else",
    "elseif",
    "local",
    "while",
    "for",
    "repeat",
    "until",
    "return",
    "nil",
    "true",
    "false",
    "and",
    "break",
    "do",
    "goto",
    "in",
    "not",
    "or",
    "then"
  };
  return reserved.contains(name);
}

final SourceFile sourceFile;

GrammarParser(this.sourceFile);

T _setNodeSpan<T extends AstNode>(T node, int start, int end, State state) {
    node.setSpan(sourceFile.span(start, end));
    return node;
  }

%%

`void`
ShebangLine =>
  S '#!' [a-zA-Z0-9_./]+ S

`Program`
Start =>
  {
    final startPos = state.position;
  }
  ShebangLine?
  S
  statements = Statements
  EOF
  $ = {
    final node = Program(statements);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`List<AstNode>`
Statements =>
{
  List<AstNode> statements = [];
}
@while (*) {
  (
    OneOrMoreSemicolons
    {
      // No statement, but we used some semicolons
    }
    ----
    OptionalSemi
    st = Statement
    OptionalSemi
    {
      statements.add(st);
    }
  )
}
$ = {
  $$ = statements;
}



`void`
OneOrMoreSemicolons =>
{
  // Must consume at least one semicolon
}
S
(';')+
S

`AstNode`
Statement => (

   IfStatement
   ----
  Assignment
  ----
   TableKeyAssignment
  ----
  LocalDeclaration
  ----
  WhileStatement
  ----
  ForLoop
  ----
  ForInLoop
  ----
  RepeatUntilLoop
  ----
  FunctionDef
  ----
  LocalFunctionDef
  ----
  ReturnStatement
  ----
  YieldStatement
  ----
  MetatableAssignment
  ----
  ExpressionStatement
  ----
  Break
  ----
  Label
  ----
  Goto
  ----
  DoBlock
  ----
  DirectStringFunctionCall

)

`AstNode`
MetatableAssignment =>
    {
        final startPos = state.position;
    }
    base = FunctionCall
    '.' S
    field = ID
    '=' S
    exprs = ExpressionList S
    $ = {
        final node = Assignment([ TableAccessExpr(base, field) ], exprs);
        $$ = _setNodeSpan(node, startPos, state.position, state);
    }

### Assignment (x = 10 or k, v = next(t))
`Assignment`
Assignment =>
  {
    List<AstNode> targets = [];
    final startPos = state.position;
  }
  first = AssignmentTarget
  { targets.add(first); }
  @while (*) {
    ',' S
    next = AssignmentTarget
    { targets.add(next); }
  }
  '=' S
  expr = ExpressionList
  S
  $ = {
    final node = Assignment(targets, expr);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

### Assignment target (variable or table field)
`AstNode`
AssignmentTarget =>
  (
    target = TableLookup
    $ = { $$ = target; }
    ----
    target = ID
    $ = { $$ = target; }
  )



`AstNode`
ComplexTableAccess =>
    {
        AstNode? expr;
        final startPos = state.position;
    }
    (
        base = ID
        { expr = base; }
        ----
        '(' S
        base = Expression
        ')' S
        { expr = base; }
        ----
        base = FunctionCall
        { expr = base; }
    )

    &{ expr != null }

    @while (+) {
        (
            '[' S
            idx = Expression
            ']' S
            {
                expr = TableAccessExpr(expr!, idx);
            }
            ----
            '.' S
            fld = ID
            {
                expr = TableAccessExpr(expr!, fld);
            }
        )

        @while (*) {
            (
                '[' S
                idx = Expression
                ']' S
                {
                    expr = TableAccessExpr(expr!, idx);
                }
                ----
                '.' S
                fld = ID
                {
                    expr = TableAccessExpr(expr!, fld);
                }
            )
        }
    }

    $ = {
        $$ = _setNodeSpan(expr!, startPos, state.position, state);
    }


`void`
OptionalSemi =>
    @while (*){
       S
       (';')+
        S

       }

### words[i] = w / table.sentence.words[i] = w
`AssignmentIndexAccessExpr`
TableKeyAssignment =>
    {
        final startPos = state.position;
        AssignmentIndexAccessExpr? node;
    }
    (
       S identifier = S '[' S key = Expression S ']' S '=' S value = Expression S
       {  node = AssignmentIndexAccessExpr(identifier as AstNode, key, value); }
        ----
        S identifier = ID S '[' S key = Expression S ']' S '=' S value = Expression S
        {node = AssignmentIndexAccessExpr(identifier, key, value);}
    )
    $ = {
     $$ = _setNodeSpan(node!, startPos, state.position, state);
    }


`(List<Identifier>, List<String>)`
LocalNameListWithAttribs =>
  {
    List<Identifier> ids = [];
    List<String> attribs = [];
  }
  first = ID
  {
    ids.add(first);
  }
  firstAttrib = AttributeOpt?
  {
    // Add the attribute if present, otherwise add empty string
    attribs.add(firstAttrib ?? "");
  }
  @while (*) {
    ',' S
    next = ID
    {
      ids.add(next);
    }
    nextAttrib = AttributeOpt?
    {
      // Add the attribute if present, otherwise add empty string
      attribs.add(nextAttrib ?? "");
    }
  }
  $ = {
    $$ = (ids, attribs);
  }

`String?`
AttributeOpt =>
  '<' S
  { final attrStart = state.position; }
  attr = <[a-zA-Z_][a-zA-Z0-9_]*> S
  (
     &{ _checkAttr(attr, attrStart, state.position, state) } S
    ~ { message = 'Invalid attribute $attr' start = end }
  )
   S
  '>' S
  $ ={ $$ = attr; }

`LocalDeclaration`
LocalDeclaration =>
{
  List<Identifier>? names = [];
  List<String>? attributes = [];
  List<AstNode>? expressions = [];
  final startPos = state.position;
}
  'local' S
  (
    result = LocalNameListWithAttribs
    {
      names = result.$1;
      attributes = result.$2;
    }
  )
 (
    '='
    S
    exprs = ExpressionList
    { expressions = exprs; }
    S
  )?
  $ = {
    // If there's no '=' part, expressions will be empty list
    final node = LocalDeclaration(names, attributes, expressions);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


### If Statement (if cond then ... end)
`IfStatement`
IfStatement =>
  {
    final startPos = state.position;
  }
  'if' S
  cond = Expression
  S 'then' S
  thenBlock = Statements
  elseifs = ElseIfList?
  { List<AstNode> elseBlock = [];}
   (
    'else' S
     statements = Statements
     { elseBlock = statements; }
  )?
  S 'end' S
  $ = {
    final node = IfStatement(cond, elseifs, thenBlock, elseBlock);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


`List<ElseIfClause>`
ElseIfList =>
  {
    List<ElseIfClause> clauses = [];
    final startPos = state.position;
  }
  @while (*) {
    'elseif' S
    cond = Expression S
    'then' S
    block = Statements
    {
      final clause = ElseIfClause(cond, block);
      _setNodeSpan(clause, startPos, state.position, state);
      clauses.add(clause);
    }
  }
  $ = {
    $$ = clauses;
  }


### While Statement (while cond do ... end)
`WhileStatement`
WhileStatement =>
  {
    final startPos = state.position;
  }
  'while' !IdChar S
  cond = Expression
  (
    'do' !IdChar S
    ~ { message = 'Expected `do` after condition in while loop' }
  )
  body = Statements
  (
    'end' !IdChar S
    ~ { message = 'Expected `end` to close while loop' }
  )
  $ = {
    final node = WhileStatement(cond, body);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


### For Loop (for i = 1, 10 do ... end)
`ForLoop`
ForLoop =>
  {
    AstNode stepExpr = NumberLiteral(1);
    final startPos = state.position;
  }
  'for' !IdChar S
  variable = ID
  '=' S
  start = Expression
  ',' S
  endExpr = Expression

  (
    ',' S
    stepVal = Expression
    {
      stepExpr = stepVal;
    }
    ----
    {
      stepExpr = NumberLiteral(1);
    }
  )
    (
      'do' S
      ~ { message = 'Expected `do` after for loop' }
    )

    body = Statements

    ('end' S
      ~ { message = 'Expected `end` to close for loop' }
    )
  $ = {
    final node = ForLoop(variable, start, endExpr, stepExpr, body);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


`ForInLoop`
ForInLoop =>
  {
    final startPos = state.position;
  }
  'for' !IdChar S
  names = NameList
  S
  'in' !IdChar S
  iterators = ExpressionList
  S
  'do' !IdChar S
  body = Statements
  'end' !IdChar S
  $ = {
    final node = ForInLoop(names, iterators, body);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`List<Identifier>`
NameList =>
  {
    List<Identifier> names = [];
    final startPos = state.position;
  }
  first = ID
  { names.add(first); }
  @while (*) {
    ',' S
    nxt = ID
    { names.add(nxt); }
  }
  $ = {
    $$ = names;
  }



### Repeat-Until Loop (repeat ... until cond)
`RepeatUntilLoop`
RepeatUntilLoop =>
  {
    final startPos = state.position;
  }
  'repeat' !IdChar S
  body = Statements
  (
    'until' !IdChar S
    ~ { message = 'Expected `until` to close repeat-until loop' }
    )
    cond = Expression

  S
  $ = {
    final node = RepeatUntilLoop(body, cond);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`ReturnStatement`
ReturnStatement =>
  {
    final startPos = state.position;
  }
  'return' !IdChar S
  exprs = ExpressionList?
  S
  $ = {
    final node = ReturnStatement(exprs);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`YieldStatement`
YieldStatement =>
  {
    final startPos = state.position;
  }
  'return' !IdChar S
  exprs = ExpressionList?
  S
  $ = {
    final node = YieldStatement(exprs);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`(List<Identifier>, bool)`
ParameterList =>
  {
    List<Identifier> params = [];
    bool hasVararg = false;
  }
  (
    varargMatch = Vararg
    {
      hasVararg = true;
    }
    ----
    first = ID
    {
      params.add(first);
    }
    @while (*) {
      ',' S
      next = ID
      {
        params.add(next);
      }
    }
    (
      ',' S
      varargMatch = Vararg
      {
        hasVararg = true;
      }
      ----
      varargMatch = Vararg
      {
        hasVararg = true;
      }
    )?
  )?
  $ = {
    $$ = (params, hasVararg);
  }


`FunctionDef`
FunctionDef =>
  {
    final startPos = state.position;
    bool implicitSelf = false;
  }
  'function' !IdChar S
  fname = FunctionName
  {
    implicitSelf = fname.method != null;
  }
  funcBody = FunctionBody
  $ = {
    final node = FunctionDef(fname, funcBody, implicitSelf: implicitSelf);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`LocalFunctionDef`
LocalFunctionDef =>
  {
    final startPos = state.position;
  }
  'local' !IdChar S 'function' !IdChar S
  name = ID S
  funcBody = FunctionBody
  $ = {
    final node = LocalFunctionDef(name, funcBody);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`FunctionName`
FunctionName =>
  {
    final startPos = state.position;
  }
  first = ID
  {
    List<Identifier> rest = [];
  }
  @while (*) {
    '.' S
    next = ID
    {
      rest.add(next);
    }
  }
  { Identifier?  method; }
   (':' S
   m = ID
   {
     method = m;
   }
   )?
  S
  $ = {
    final node = FunctionName(first, rest, method);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`VarArg`
Vararg =>
  {
    final startPos = state.position;
  }
  '...' S
  $ = {
    final node = VarArg();
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`FunctionBody`
FunctionBody =>
  {
    final startPos = state.position;
    List<Identifier> params = [];
    bool hasVararg = false;
    bool implicitSelf = false;
  }
  '(' S
  paramResult = ParameterList?
  {
      params = paramResult.$1;
      hasVararg = paramResult.$2;
  }
  ')' S
  body = Statements
  'end' S
  $ = {
    final node = FunctionBody(params, body, hasVararg, implicitSelf: implicitSelf);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


`FunctionLiteral`
FunctionLiteral =>
  {
    final startPos = state.position;
  }
  'function' S
  funcBody = FunctionBody
  $ = {
    final node = FunctionLiteral(funcBody);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

### Expression rules with proper precedence
`AstNode`
Expression =>
  {
    final startPos = state.position;
  }
  expr = OrExpression
  $ = {
    $$ = _setNodeSpan(expr, startPos, state.position, state);
  }

`AstNode`
OrExpression =>
  {
    final startPos = state.position;
  }
  result = AndExpression
  @while (*) {
    S
    'or'
    S
    right = AndExpression
    {
      result = BinaryExpression(result, "or", right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
AndExpression =>
  {
    final startPos = state.position;
  }
  result = ComparisonExpression
  @while (*) {
    S
    'and'
    S
    right = ComparisonExpression
    {
      result = BinaryExpression(result, "and", right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
ComparisonExpression =>
  {
    final startPos = state.position;
  }
  result = BitwiseExpression
  @while (*) {
    S
    op = <(
      '=='
      ---
      '~='
      ---
      '<='
      ---
      '>='
      ---
      '<'
      ---
      '>'
    )>
    S
    right = BitwiseExpression
    {
      result = BinaryExpression(result, op, right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
BitwiseExpression =>
  {
    final startPos = state.position;
  }
  result = ShiftExpression
  @while (*) {
    S
    op = <([&~|])>
    S
    right = ShiftExpression
    {
      result = BinaryExpression(result, op, right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
ShiftExpression =>
  {
    final startPos = state.position;
  }
  result = ConcatExpression
  @while (*) {
    S
    op = <('<<' / '>>')>
    S
    right = ConcatExpression
    {
      result = BinaryExpression(result, op, right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
ConcatExpression =>
  {
    final startPos = state.position;
  }
  result = AdditiveExpression
  @while (*) {
    S
    '..'
    S
    right = AdditiveExpression
    {
      result = BinaryExpression(result, "..", right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
AdditiveExpression =>
  {
    final startPos = state.position;
  }
  result = MultiplicativeExpression
  @while (*) {
    S
    op = <[+\-]>
    S
    right = MultiplicativeExpression
    {
      result = BinaryExpression(result, op, right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
MultiplicativeExpression =>
  {
    final startPos = state.position;
  }
  result = ExponentiationExpression
  @while (*) {
    S
    { String op = "";}
    (

     operator = "//"
        {
          op = operator;
        }

    ----
   operator = <[*/%]>
       {
         op = operator;
       }
    )
    S
    right = ExponentiationExpression
    {
      result = BinaryExpression(result, op, right);
    }
  }
  $ = {
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
ExponentiationExpression =>
  {
    final startPos = state.position;
  }
  left = UnaryExpression
  (
    S
    '^'
    S
    right = UnaryExpression
    {
      left = BinaryExpression(left, "^", right);
    }
  )*
  $ = {
    $$ = _setNodeSpan(left, startPos, state.position, state);
  }

`AstNode`
UnaryExpression =>
  (
    {
      final startPos = state.position;
    }
    op = Unop
    S
    expr = UnaryExpression
    $ = {
      final node = UnaryExpression(op, expr);
      $$ = _setNodeSpan(node, startPos, state.position, state);
    }
  )
  ----
  SimpleExpression

`AstNode`
DirectStringCall =>
    {
        AstNode? expr;
        final startPos = state.position;
    }
    name = ID
    (
        '"' str = DoubleChars? '"'
        {
            final strContent = str;
            expr = FunctionCall(name, [StringLiteral(strContent)]);
        }
        ----
        '\'' str = SingleChars? '\''
        {
            final strContent = str;
            expr = FunctionCall(name, [StringLiteral(strContent)]);
        }
    )
    @while(*) {
        S '.' S
        fld = ID
        (
            '(' S
            callArgs = ExpressionList?
            ')' S
            {
                expr = FunctionCall(TableAccessExpr(expr!, fld), callArgs );
            }
            ----
            {
                expr = TableAccessExpr(expr!, fld);
            }
        )
    }
    $ = {
        $$ = _setNodeSpan(expr!, startPos, state.position, state);
    }


`AstNode`
FunctionCallWithTableAccess =>
    {
        AstNode? baseExpr;
        final startPos = state.position;
    }
    (
        base = FunctionCall
        { baseExpr = base; }
        ----
        base = TableFieldAccess
        { baseExpr = base; }
        ----
        base = TableLookup
        { baseExpr = base; }
        ----
        base = ID
        { baseExpr = base; }
        ----
        '(' S expr = Expression ')' S
        { baseExpr = expr; }
    )

    &{ baseExpr != null }

    @while (+) {
        (
            '(' S
            args = ExpressionList?
            ')' S
            {
                baseExpr = FunctionCall(baseExpr!, args);
            }
            ----
            '.' S
            field = ID
            {
                baseExpr = TableAccessExpr(baseExpr!, field);
            }
            ----
            '[' S
            index = Expression
            ']' S
            {
                baseExpr = TableAccessExpr(baseExpr!, index);
            }
            ----
            ':' S
            methodName = ID
            S
            args = Args
            {
                baseExpr = MethodCall(baseExpr!, methodName, args, implicitSelf: true);
            }
        )
    }

    $ = {
        $$ = _setNodeSpan(baseExpr!, startPos, state.position, state);
    }


`AstNode`
SimpleExpression =>
  {
    final startPos = state.position;
    AstNode? result;
  }
  (
    expr = TableIndexAccess
    { result = expr; }
    ----
    expr = FunctionCallWithTableAccess
    { result = expr; }
    ----
    expr = DirectStringCall
    { result = expr; }
    ----
    expr = FunctionCall
    { result = expr; }
    ----
    expr = FunctionLiteral
    { result = expr; }
    ----
    expr = TableConstructor
    { result = expr; }
    ----
    expr = NilValue
    { result = expr; }
    ----
    expr = VarArg
    { result = expr; }
    ----
    expr = ComplexTableAccess
    { result = expr; }
    ----
    expr = TableFieldAccess
    { result = expr; }
    ----
    expr = TableLookup
    { result = expr; }
    ----
    expr = ID
    { result = expr; }
    ----
    expr = PrimaryExpression
    { result = expr; }
  )
  $ = {
    $$ = _setNodeSpan(result!, startPos, state.position, state);
  }

`ExpressionStatement`
ExpressionStatement =>
  {
    final startPos = state.position;
  }
  expr = Expression
  S
  $ = {
    final node = ExpressionStatement(expr);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


`String`
Unop =>

    'not'
    ----
    '-'
    ----
    '#'
    ----
    '~'
    ----
    '!'
    ----
    '&'
    ----
    '|'
    ----
    '^'


`DoBlock`
DoBlock =>
  {
    final startPos = state.position;
  }
  'do' S
  block = Statements
  'end' S
  $ = {
    final node = DoBlock(block);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`Break`
Break =>
  {
    final startPos = state.position;
  }
  'break' S
  $ = {
    final node = Break();
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`Label`
Label =>
  {
    final startPos = state.position;
  }
  '::' label = ID '::' S
  $ = {
    final node = Label(label);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`Goto`
Goto =>
  {
    final startPos = state.position;
  }
  'goto' S name = ID S
  $ = {
    final node = Goto(name);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }



`VarArg`
VarArg =>
  {
    final startPos = state.position;
  }
  '...' S
  $ = {
    final node = VarArg();
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`ExpressionStatement`
DirectStringFunctionCall =>
  {
    String strContent = '';
    final startPos = state.position;
  }
  name = <ID/TableFieldAccess>
  (
    '"' str = DoubleChars? '"'
    {
      strContent = str;
    }
    ----
    '\'' str = SingleChars? '\''
    {
      strContent = str;
    }
  )

  {
    final identifier = Identifier(name);
    final stringLit = StringLiteral(strContent);
    AstNode expr = FunctionCall(identifier, [stringLit]);
  }

    @while (*) {
      S '.' S
      field = ID
      {
        expr = TableAccessExpr(expr, field);
      }
    }

    (
      S '(' S
      callArgs = ExpressionList?
      ')' S
      {
        expr = FunctionCall(expr, callArgs);
      }
      ----
      S
      {
      }
    )


  $ = {
    final node = ExpressionStatement(expr);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


`Call`
FunctionCall =>
  {
    Call? call;
    AstNode? prefix;
    final startPos = state.position;
  }
  (
    pref =  TableFieldAccess
    {
      prefix = pref;
    }
     ---
      pref = ID
    {
      prefix = pref;
    }
  )
  (
    args = Args
    {
      call = FunctionCall(prefix!, args);
    }
    ----
    ':' S methodName = ID S args = Args
    {
      call = MethodCall(prefix!, methodName, args, implicitSelf: true);
    }
    ----
    '.' S methodName = ID S args = Args
    {
      call = MethodCall(prefix!, methodName, args, implicitSelf: true);
    }
  )
  $ = {
    $$ = _setNodeSpan(call!, startPos, state.position, state);
  }

`List<AstNode>`
Args =>
  {
    List<AstNode> result = [];
  }
  (
    '(' S exprs = ExpressionList? TrailingComma ')' S
    { result = exprs; }
    ----
    table = TableConstructor
    { result = [table]; }
    ----
    str = String
    { result = [str]; }
  )
  $ = {
    // Args doesn't need _setNodeSpan since it's just returning a list, not an AstNode
    $$ = result;
  }

`void`
TrailingComma =>
  (
    ',' S
  )?



`List<AstNode>`
ExpressionList =>
  {
    List<AstNode> entries = [];
  }
  (
    first = Expression
    {
      entries.add(first);
    }
    @while (*) {
      ',' S
      (
        nxt = Expression
        {
          entries.add(nxt);
        }
        ----
        { }
      )
    }
  )?
  TrailingComma?

  $ = {
    $$ = entries;
  }

`AstNode`
PrimaryExpression => (
    Number
    ----
    String
    ----
    Boolean
    ----
    NilValue
    ----
    TableFieldAccess
    ----
    TableLookup
    ----
    ID
    ----
    TableConstructor
    ----
    {
        final startPos = state.position;
    }
    '(' S
    inner = Expression
    $ = {
        final node = GroupedExpression(inner);
        $$ = _setNodeSpan(node, startPos, state.position, state);
    }
    (
        ')' S
        ~ { message = 'Expected closing parenthesis' }
    )
)


`AstNode`
TableIndexAccess =>
  {
    AstNode? expr;
    final startPos = state.position;
  }
  (
    '(' S
    inner = Expression
    ')' S
    { expr = inner; }
    ----
    constructor = TableConstructor
    { expr = constructor; }

  )

  &{ expr != null }

  '[' S
  index = Expression
  ']' S
  $ = {
    final node = TableAccessExpr(expr, index);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }


`AstNode`
TableFieldAccess =>
  {
    final startPos = state.position;
  }
  table = ID
  { List<Identifier> fields = []; }
  @while(+) {
    '.' S
    field = ID
    { fields.add(field); }
  }
  $ = {
    TableAccessExpr result = TableAccessExpr(table, fields[0]);
    for (var i = 1; i < fields.length; i++) {
      result = TableAccessExpr(result, fields[i]);
    }
    $$ = _setNodeSpan(result, startPos, state.position, state);
  }

`AstNode`
TableLookup =>
  {
    AstNode? expr;
    final startPos = state.position;
  }

  # Start with an identifier
  table = ID
  { expr = table; }

  # Now handle any sequence of [expr] or .field accesses
  @while (+) {
    (
      '[' S
      index = Expression
      ']' S
      { expr = TableAccessExpr(expr!, index); }
      ----
      '.' S
      field = ID
      { expr = TableAccessExpr(expr!, field); }
    )
  }

  $ = {
    $$ = _setNodeSpan(expr!, startPos, state.position, state);
  }

`NumberLiteral`
Number =>
  {
    final startPos = state.position;
  }
  n = <
    ('0x' [0-9A-Fa-f]+ ('.' [0-9A-Fa-f]+)? ([pP][+-]?[0-9]+)?)
    ----
    [0-9]+ ('.' [0-9]+)? ([eE][+-]?[0-9]+)?
  >
  S
  $ = {
    final node = NumberLiteral(num.parse(n));
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }
`StringLiteral`
String =>
  {
    String value = '';
    final startPos = state.position;
  }
  (
    c = LongString
    {value = c;}
    ----
    '"' c = DoubleChars? '"' S
    {value = c;}
    ----
    '\'' c = SingleChars? '\'' S
    {value = c;}
  )
  $ = {
    final node = StringLiteral(value);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`String`
LongString =>
    {
      String text = '';
      int eqCount = 0;
      final startPos = state.position;
    }
    '[' eqs = <('='*)> '[' S?
    {
      eqCount = eqs.length;
    }
    content = <(
      !( ']' eqs2 = <('='*)> ']' &{ eqs2.length == eqCount } ) .
    )*>
    ']' eqs3 = <('='*)> ']'
    &{
      eqs3.length == eqCount
    }
    S?
    $ = {
      $$ = content;
    }

`String`
DoubleChars =>
    <(
      '\\' . /
      !'"' .
    )*>

`String`
SingleChars =>
    <(
      '\\' . /
      !"'" .
    )*>

`BooleanLiteral`
Boolean =>
  {
    final startPos = state.position;
  }
  'true' !IdChar S
  $ = {
    final node = BooleanLiteral(true);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }
  ----
  {
    final startPos = state.position;
  }
  'false' !IdChar S
  $ = {
    final node = BooleanLiteral(false);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`NilValue`
NilValue =>
  {
    final startPos = state.position;
  }
  'nil' !IdChar S
  $ = {
    final node = NilValue();
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

### Tables { key = value, ... }
`TableConstructor`
TableConstructor =>
  {
    final startPos = state.position;
  }
  '{' S
  entries = TableEntries?
  '}' S
  $ = {
    final node = TableConstructor(entries ?? []);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

`List<TableEntry>`
TableEntries =>
  {
    List<TableEntry> entries = [];
  }
  (
    first = TableEntry
    { entries.add(first); }
    @while (*) {
      (
        ',' S
        ----
        ';' S
      )
      next = TableEntry
      { entries.add(next); }
    }
  )
  (
    ',' S
    ----
    ';' S
  )?

  $ = {
    $$ = entries;
  }


`TableEntry`
TableEntry =>
  {
    final startPos = state.position;
    TableEntry? node;
  }
  (
    '[' S key = Expression S ']' S '=' S value = Expression
     {
      node = KeyedTableEntry(key, value);
    }
    ----
    key = ID S '=' S value = Expression
    {
      node = KeyedTableEntry(key, value);
    }
    ----
    expr = Expression
    {
       node = TableEntryLiteral(expr);
    }
  )
  $ = {
    $$ = _setNodeSpan(node as TableEntry, startPos, state.position, state);
  }

IdChar =>
  [a-zA-Z0-9_]

`Identifier`
ID =>
  {
    final startPos = state.position;
  }
  identifier = <[a-zA-Z_][a-zA-Z0-9_]*>
   !{ isReserved(identifier) }
  S
  $ = {
    final node = Identifier(identifier);
    $$ = _setNodeSpan(node, startPos, state.position, state);
  }

EOF =>
  !.

`void`
S =>
{ List<dynamic> comment = []; }
  (
    c = [ \t\r\n]
    { comment.add(c); }
    ----
    c = '--[[' (!']]' .)* ']]'
    { comment.add(c); }
    ----
    c = '--[=[' (!']=]' .)* ']=]'
    { comment.add(c); }
    ----
    c =  '--[==[' (!']==]' .)* ']==]'
    { comment.add(c); }
    ----
    c =  '--' [^\n]* [\n]?
    { comment.add(c); }
  )*

