---
description:
globs:
alwaysApply: false
---
# Coroutine Implementation and Usage Guide

This guide summarizes the key aspects of implementing and properly using coroutines, based on the Lua 5.4 reference manual and our recent work.

## Core Concepts

*   **Coroutines as Collaborative Multithreading**: Coroutines represent independent threads of execution that explicitly suspend their execution by calling `coroutine.yield`. They are cooperative, not preemptive.
*   **Coroutine States**:
    *   `suspended`: The coroutine has been created but not yet started, or it has yielded.
    *   `running`: The coroutine is currently executing.
    *   `normal`: The coroutine is active but not running (it has resumed another coroutine).
    *   `dead`: The coroutine has finished its main function or stopped with an error.

## Key Components and Interactions

### 1. `Coroutine` Class (`[lib/src/coroutine.dart](mdc:lib/src/coroutine.dart)`)

This class manages the lifecycle and state transitions of a coroutine.

*   **`CoroutineStatus` Enum**: Defines the possible states of a coroutine.
*   **`resume(List<Object?> args)` Method**:
    *   The primary method to start or resume a coroutine.
    *   Handles transitions from `suspended` to `running`.
    *   Manages the `Completer<List<Object?>>` to pause and resume execution.
    *   Catches `YieldException` (setting status to `suspended` and returning yielded values).
    *   Catches `ReturnException` (setting status to `dead` upon normal function completion).
    *   Catches other exceptions (setting status to `dead` and returning error).
    *   The `finally` block correctly restores the `previousCoroutine`'s status to `normal` or `running` if it was previously `normal`.
*   **`yield_(List<Object?> values)` Method**:
    *   Called by the coroutine to suspend its execution.
    *   Sets the coroutine's status to `suspended`.
    *   Completes the current `Completer` with the `yield` values.
    *   Throws a `YieldException` containing the new `Completer`'s future, which will be awaited by the next `resume` call.
*   **`_executeCoroutine()` Method**:
    *   Executes the coroutine's main function.
    *   Propagates `YieldException` (thrown by `yield_`) and `ReturnException` (for normal function returns) back to the `resume` method using `rethrow`.
    *   Ensures `completer.complete()` is called on normal function termination, transitioning the coroutine to `dead`.

### 2. `Interpreter` Class (`[lib/src/interpreter/interpreter.dart](mdc:lib/src/interpreter/interpreter.dart)`)

The interpreter interacts with coroutines, primarily through `setCurrentCoroutine`.

*   **`setCurrentCoroutine(Coroutine? coroutine)` Method**:
    *   This method is solely responsible for setting the `_currentCoroutine` reference.
    *   **Crucially, it does NOT alter the coroutine's status.** Status management is handled exclusively within the `Coroutine` class.

### 3. `lib_coroutine.dart` (`[lib/src/stdlib/lib_coroutine.dart](mdc:lib/src/stdlib/lib_coroutine.dart)`)

This file contains the `coroutine` standard library functions.

*   **`coroutine.status(coroutine)` Function**:
    *   Returns the string representation of a coroutine's status.
    *   **Special Case**: If the queried coroutine is the `currentCoroutine` and its internal status is `suspended`, it should report "running". This reflects the Lua behavior where a yielded coroutine that is being resumed is considered "running" from the perspective of the `status` function.

## Key Learnings and Best Practices

*   **Centralized Status Management**: Coroutine status changes should primarily occur within the `Coroutine` class's `resume` and `yield_` methods. The `Interpreter` should only manage the active coroutine reference, not its status.
*   **Exception-based Control Flow**: `YieldException` and `ReturnException` are crucial for controlling the flow between `_executeCoroutine` and `resume`, allowing for proper suspension and termination.
*   **`Completer` Usage**: `Completer` instances are essential for pausing and resuming coroutine execution, enabling `yield` to return control and `resume` to await continuation.
*   **Lua Specification Adherence**: Always refer to the Lua 5.4 reference manual for expected behavior, especially concerning `coroutine.status` and the exact return values/error handling of `resume` and `yield`. This was critical in correctly handling the "running" status for a suspended-but-current coroutine.
*   **Thorough Debugging**: Utilize `Logger.debug` extensively to trace coroutine status changes and execution flow, especially when dealing with asynchronous operations and exceptions. This was invaluable in pinpointing subtle misbehaviors.

